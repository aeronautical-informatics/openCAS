//! Cas_rs has been created by DLR FT-SSY-AES. It is an updated rust version of previous work done by Stanford Intelligent Systems Laboratory (SISL).
//! SISL has created neural network projects called `VerticalCAS` and `HorizontalCAS`. These systems represent the behaviour of the
//! Airborne Collision Avoidance System (ACAS) which is currently in development to replace TCAS. For more details on SISL work please go
//! [here](https://github.com/sisl/HorizontalCAS).
//! This project currently focuses to use the done work on embedded systems in safety critical environments. Therefore, the orginal code made in
//! Python and Julia is not sufficient.
//! Currently the project only implements the code of HorizontalCAS. The implementation of VerticalCAS is coming soon.

use inference::Vector;
use uom::si::f32::*;
//use uom:: si::u8::*;
use uom::si::angle::radian;
use uom::si::length::foot;
use uom::si::time::second;
use uom::si::velocity::foot_per_minute;

/// This module contains autogenerated instances of all nnet files found in the `nnets` directory.
/// Every nnet file is the written representation of a trained neural network.
/// The nnet file contains all weight matrices and bias vectors (plus some more useful data) that define the network.
/// Therefore, this module 'digitalizes' all files and makes them awailable at runtime without any further file parsing.
#[allow(dead_code)]
#[allow(non_upper_case_globals)]
#[allow(clippy::approx_constant)]
mod nnets {
    use crate::inference::{Layer, NNet};
    use nalgebra::{matrix, vector};

    include!(concat!(env!("OUT_DIR"), "/nnets.rs"));
}

/// This module is inferencing the input data specific to the network with the network itself.
/// In doing so, the input data will be passed through all network layers and an evaluation will be given as the network output.
mod inference;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]

/// This will store the last given advisory in order to locate the correct network in the evaluation.
pub struct HCas {
    pub last_advisory: HAdvisory,
}

/// HAdvisory stores all possible output evaluations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HAdvisory {
    ClearOfConflict = 0,
    WeakLeft = 1,
    WeakRight = 2,
    StrongLeft = 3,
    StrongRight = 4,
}

impl HCas {
    /// As you can see by looking into the `nnets` folder, there have been 40 individual networks trained.
    /// The reason behind this is that SISL has had runtime problems with bigger networks.
    /// A way to circumvent this problem is to cut a potentionally big network into many smaller ones.
    /// The smaller networks are in return specifically trained just for a certain set of possible scenerios.
    /// The purpose of this method is to pick the best specialized network to the current situation.
    /// This is done by correlating the remaining time until inpact `tau` [sec] and the last given advisory in `HCas`
    /// to the given networks.
    ///
    /// Once this is done, the current inputs `range` [ft],
    /// `theta`('bearing' angle from homeship to intruder) [rad] and
    /// `psi` (bearing angle of intruder relative to flight direction of the homeship) [rad] are fed through to
    /// the correct network.   
    ///
    /// The angles are measured in the mathematical sense, e.g. `theta` = 5° => intruder is slidely on the left of the homeships heading.
    /// If `psi` was 90° or pi/2, it would mean that the intruder was flying to the left perpendicular to the homeships heading. See [figure 3](https://arxiv.org/pdf/1912.07084.pdf).
    pub fn process(
        &mut self,
        tau: Time,
        range: Length,
        theta: Angle,
        psi: Angle,
    ) -> (HAdvisory, f32) {
        let index = match tau.get::<second>() {
            t if (0.0..5.0).contains(&t) => 0,
            t if (5.0..10.0).contains(&t) => 1,
            t if (10.0..15.0).contains(&t) => 2,
            t if (15.5..20.0).contains(&t) => 3,
            t if (20.0..30.0).contains(&t) => 4,
            t if (30.0..40.0).contains(&t) => 5,
            t if (40.0..60.0).contains(&t) => 6,
            _ => 7,
        };

        let nnet = &nnets::HCAS_NNETS[self.last_advisory as usize][index];
        let inputs: Vector<3> = nalgebra::vector![
            range.get::<foot>() * theta.get::<radian>().cos(),
            range.get::<foot>() * theta.get::<radian>().sin(),
            psi.get::<radian>()
        ];

        let evaluated = nnet.eval(inputs);
        let priority = evaluated.max();

        self.last_advisory = match evaluated.imax() {
            0 => HAdvisory::ClearOfConflict,
            1 => HAdvisory::WeakLeft,
            2 => HAdvisory::WeakRight,
            3 => HAdvisory::StrongLeft,
            4 => HAdvisory::StrongRight,
            _ => todo!(),
        };

        (self.last_advisory, priority)
    }
}

//***** Here begins the verticalCAS *****//

#[derive(Debug, Clone, Copy, PartialEq, Eq)]

/// This will store the last given advisory in order to locate the correct network in the evaluation.
pub struct VCas {
    pub last_advisory: VAdvisory,
}

/// HAdvisory stores all possible output evaluations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum VAdvisory {
    ClearOfConflict = 0,
    DoNotClimb = 1,
    DoNotDescend = 2,
    Descend1500 = 3,
    Climb1500 = 4,
    StrengthenDescend1500 = 5,
    StrengthenClimb1500 = 6,
    StrengthenDescend2500 = 7,
    StrengthenClimb2500 = 8,
}

impl VCas {
    /// The VerticalCAS contains 9 different networks.
    ///
    /// There are 4 specific inputs:
    /// + Relative intruder altitude [ft]: vertical distance between intruder and homeship
    /// + Vertical speed of homeship [ft/min]
    /// + Vertical speed of intruder [ft/min]
    /// + time until horizontal seperation loss: tau [sec]
    pub fn process(
        &mut self,
        height: Length,
        vertical_speed_homeship: Velocity,
        vertical_speed_intruder: Velocity,
        tau: Time,
    ) -> (VAdvisory, f32) {
        let nnet = &nnets::VCAS_NNETS[self.last_advisory as usize];
        let inputs: Vector<4> = nalgebra::vector![
            height.get::<foot>(),
            vertical_speed_homeship.get::<foot_per_minute>(),
            vertical_speed_intruder.get::<foot_per_minute>(),
            tau.get::<second>()
        ];

        let evaluated = nnet.eval(inputs);
        let priority = evaluated.max();

        self.last_advisory = match evaluated.imax() {
            0 => VAdvisory::ClearOfConflict,
            1 => VAdvisory::DoNotClimb,
            2 => VAdvisory::DoNotDescend,
            3 => VAdvisory::Climb1500,
            4 => VAdvisory::Descend1500,
            5 => VAdvisory::StrengthenClimb1500,
            6 => VAdvisory::StrengthenDescend1500,
            7 => VAdvisory::StrengthenClimb2500,
            8 => VAdvisory::StrengthenDescend2500,
            _ => todo!(),
        };

        (self.last_advisory, priority)
    }
}
